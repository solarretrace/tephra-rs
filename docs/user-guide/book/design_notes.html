<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Design Notes - Tephra User&#x27;s Guide</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="design_goals.html">Design Goals</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="terminology.html"><strong aria-hidden="true">2.</strong> Terminology</a></li><li class="chapter-item expanded "><a href="create_the_scanner.html"><strong aria-hidden="true">3.</strong> Create the Scanner</a></li><li class="chapter-item expanded "><a href="create_the_lexer.html"><strong aria-hidden="true">4.</strong> Create the Lexer</a></li><li class="chapter-item expanded "><a href="create_the_parser.html"><strong aria-hidden="true">5.</strong> Create the Parser</a></li><li class="chapter-item expanded "><a href="handling_errors.html"><strong aria-hidden="true">6.</strong> Handling Errors</a></li><li class="chapter-item expanded "><a href="wrapping_up.html"><strong aria-hidden="true">7.</strong> Wrapping Up</a></li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">8.</strong> Debugging</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="spans.html"><strong aria-hidden="true">9.</strong> Spans</a></li><li class="chapter-item expanded "><a href="lexer.html"><strong aria-hidden="true">10.</strong> Lexer</a></li><li class="chapter-item expanded "><a href="combinators.html"><strong aria-hidden="true">11.</strong> Combinators</a></li><li class="chapter-item expanded "><a href="parse_errors.html"><strong aria-hidden="true">12.</strong> Parse Errors</a></li><li class="chapter-item expanded "><a href="parse_results.html"><strong aria-hidden="true">13.</strong> Parse Results</a></li><li class="chapter-item expanded affix "><li class="part-title">Combinator Reference</li><li class="chapter-item expanded "><a href="primitive_combinators.html"><strong aria-hidden="true">14.</strong> Primitive Combinators</a></li><li class="chapter-item expanded "><a href="repetition_combinators.html"><strong aria-hidden="true">15.</strong> Repetition Combinators</a></li><li class="chapter-item expanded "><a href="join_combinators.html"><strong aria-hidden="true">16.</strong> Join Combinators</a></li><li class="chapter-item expanded "><a href="control_combinators.html"><strong aria-hidden="true">17.</strong> Control Combinators</a></li><li class="chapter-item expanded "><a href="section_combinators.html"><strong aria-hidden="true">18.</strong> Section Combinators</a></li><li class="chapter-item expanded affix "><li class="part-title">Developer Reference</li><li class="chapter-item expanded "><a href="project_layout.html"><strong aria-hidden="true">19.</strong> Project Layout</a></li><li class="chapter-item expanded "><a href="design_notes.html" class="active"><strong aria-hidden="true">20.</strong> Design Notes</a></li><li class="chapter-item expanded "><a href="building.html"><strong aria-hidden="true">21.</strong> Building</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">22.</strong> Testing</a></li><li class="chapter-item expanded "><a href="tracing.html"><strong aria-hidden="true">23.</strong> Tracing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tephra User&#x27;s Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tephra-developer-design-notes"><a class="header" href="#tephra-developer-design-notes">Tephra Developer Design Notes</a></h1>
<h2 id="use-t-str-not-mut-t-str"><a class="header" href="#use-t-str-not-mut-t-str">Use <code>&amp;'t str</code>, not <code>&amp;mut &amp;'t str</code>.</a></h2>
<p>This makes it easier to back up in case of a failure. This only applies to a combined lexer/parser.</p>
<p>Different parser designs may be able to accomodate different data formats. In order to build a streaming parser, the lexer won't be able to return slices into the source, as the lexeme borrows from the lexer's internal buffer, rather than the external source text buffer.</p>
<h2 id="use-stdresult"><a class="header" href="#use-stdresult">Use <code>std::Result</code>.</a></h2>
<h2 id="if-a-function-takes-extra-args-return-a-parser"><a class="header" href="#if-a-function-takes-extra-args-return-a-parser">If a function takes extra args, return a parser.</a></h2>
<h2 id="if-a-function-takes-no-extra-args-it-is-the-parser"><a class="header" href="#if-a-function-takes-no-extra-args-it-is-the-parser">If a function takes no extra args, it is the parser.</a></h2>
<h2 id="use-fnmut"><a class="header" href="#use-fnmut">Use <code>FnMut</code></a></h2>
<h2 id="use-stderrorerror-for-failure-source"><a class="header" href="#use-stderrorerror-for-failure-source">Use <code>std::error::Error</code> for failure source.</a></h2>
<h2 id="do-not-boxown-all-parse-errors"><a class="header" href="#do-not-boxown-all-parse-errors">Do not box/own all parse errors.</a></h2>
<h2 id="impl-partialeq-on-results-for-testing"><a class="header" href="#impl-partialeq-on-results-for-testing">Impl <code>PartialEq</code> on results for testing.</a></h2>
<h2 id="return-value-lexer-on-success"><a class="header" href="#return-value-lexer-on-success">Return value, lexer on success.</a></h2>
<h2 id="dont-use-generics-for-column-metrics"><a class="header" href="#dont-use-generics-for-column-metrics">Don't use generics for column metrics.</a></h2>
<h2 id="join-spans-by-default-explicitely-separate-them"><a class="header" href="#join-spans-by-default-explicitely-separate-them">Join spans by default, explicitely separate them.</a></h2>
<p>Spans are joined extremely frequently, so it is much simpler to only specify when they should be separated. The lexer should track both its current position and the position of the last unconsumed text. This will enable lexer reuse without cloning, and allow spans to be joined implicitely.
The Lexer::next method returns the span of the most recent token on success, and on error it returns the span of unconsumed text.</p>
<h2 id="return-lexer-reason-source-on-failure"><a class="header" href="#return-lexer-reason-source-on-failure">Return lexer, reason, source on failure.</a></h2>
<h2 id="separate-lexer-and-parser"><a class="header" href="#separate-lexer-and-parser">Separate lexer and parser.</a></h2>
<p>This allows us to easily filter lexed tokens, i.e., to remove whitespace or comments. It also allows injecting tokens, i.e., to specify indentation levels, or to analyze comments using a separate parser stream. </p>
<p>Without a dedicated lexer, all intermediate syntactical structure must be filtered or created inline, and it becomes difficult to separate and analyze.</p>
<pre><code>result
span
lexer
combinator
    text
    token
primitive
    comment
    float
    integer
    list
    string
</code></pre>
<h2 id="scanner-holds-state"><a class="header" href="#scanner-holds-state">Scanner holds state</a></h2>
<p>The scanner must hold state to allow processing escaped tokens. Nested comments, matching quotes, etc., can be lexed as escaped text or as language tokens, and the scanner needs to know what the open/escape is. So whenever a scanner produces an escape token, it records that state until the corresponding close is produced.</p>
<h2 id="scanner-outputs-option"><a class="header" href="#scanner-outputs-option">Scanner outputs Option</a></h2>
<p>If the scanned text is empty, it is obvious that there is no token to scan, and if the scanner returns None, then there is no token to match the text. The main problem with this is in detecting <em>why</em> there is no match if text remains, which could be a function of the scanner state.</p>
<p>In practice, this is probably not a problem, because a parser should know whether the scanner is entering such a state, and if the parse fails, we should be able to determine why. This probably means that you can't use simple combinators for e.g., both strings and bracketed tokens, but you would usually want escaped tokens to be processed in their own parsers anyway.</p>
<p>This also means the scanner doesn't need a dedicated error type, and that parse errors arising from the scanner won't need to be boxed, which is simple and more efficient.</p>
<h2 id="scan-for-any-token-or-a-specific-token"><a class="header" href="#scan-for-any-token-or-a-specific-token">Scan for any token or a specific token?</a></h2>
<p>Scanning for specific tokens would probably be more efficient and will make scanners easier to write. Token patterns can overlap, and the same text can be matched by multiple tokens, depending on what the parser requested.</p>
<p>On the other hand, those ambiguities don't seem relevant in practice. Scanning for any token allows for cleaner iteration, and most importantly, efficiently scanning ahead to a sentinal token. It also allows for more complex filtering capabilities.</p>
<h1 id="lexer-filtering-and-span-construction"><a class="header" href="#lexer-filtering-and-span-construction">Lexer filtering and span construction</a></h1>
<p>The lexer output should be filterable and contain full-constructed spans before any parser code works on it.</p>
<h2 id="lexer-trait-or-lexer-struct"><a class="header" href="#lexer-trait-or-lexer-struct">Lexer trait or lexer struct?</a></h2>
<p>The Lexer could be a trait requiring Iterator over the lexemes. This would allow iterator combinators to do filtering and transformation of the lexer output, as well as allow arbitrary parsers to transform the lexer on demand. On the other hand, it is likely that combinator errors would get difficult to analyze, as the lexer would have many type variables. This also makes it almost impossible to interact with the lexer state during parsing. At a minumum every iterator would need to be clonable so allow backtracking in case of a failed parse.</p>
<p>The lexer could present a struct interface. This is problematic in that it strongly constrains what the lexer is allowed to do. It doesn't allow parsers to transform the lexer without including stateful operations on the lexer. Fortunately, there is not a whole lot that the typical lexer will need to do: filter whitespace, backtrack, push tokens into the stream, ... Most other options can be handled in the parser code.</p>
<h1 id="lexer-conversions"><a class="header" href="#lexer-conversions">Lexer conversions</a></h1>
<p>There's a bit of wasted effort in not doing value production in the lexer. Lexing a number or escaped string is redundant with converting it to the associated value. However, there are several ways to avoid this problem, each with different tradeoffs.</p>
<h2 id="1-non-trival-lexer-tokens"><a class="header" href="#1-non-trival-lexer-tokens">1. Non-trival lexer tokens.</a></h2>
<p>The lexer can produce the data in a single pass and emit it with the token. This means token matching becomes more complex, so we'll need to separate Tokens carrying values from TokenTypes, which are used in matching.</p>
<h2 id="2-data-in-the-lexeme"><a class="header" href="#2-data-in-the-lexeme">2. Data in the lexeme.</a></h2>
<p>The lexer always produces a value and stores it in the lexeme. This requires the parser to know which tokens produce values and of which type, so that they may be retrieved. This could involve wrapping low-level parsers in data-extractor combinators, which could be confusing. (And doing it automatically would essentially look the same as #1.)</p>
<h2 id="3-no-data-conversions-in-the-lexer"><a class="header" href="#3-no-data-conversions-in-the-lexer">3. No data conversions in the lexer.</a></h2>
<p>The lexer always produces a simple token and its span. There is some redundant effort in calculating data conversions, but it can be done using normal data conversion combinators. Additionally, if the data is unused (eg., part of a fallible parse,) this may be the most efficient approach.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="project_layout.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="building.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="project_layout.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="building.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
